<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8"/>
        <script src=https://threejs.org/build/three.js></script>
        <script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.6/dat.gui.min.js"></script>
    </head>
    <body>
        <script>
            "use strict";
            let scene, camera, renderer, cameraControls;
            let material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
            let WIDTH = window.innerWidth;
            let HEIGHT = window.innerHeight;
            let cube, geometry, loader, texture;
            let mountains, desert, snow, test;
            let cloudGeo, cloudMaterial, cloudParticles = [];
            let rain, rainGeo, rainMaterial, rainDrop, rainCount = 15000;

            function init()
            {
              scene = new THREE.Scene();
              initRenderer();
              initScene();
              handleResize();
            }

            function initRenderer()
            {
              renderer = new THREE.WebGLRenderer({ antialias: true});
              renderer.setSize(WIDTH, HEIGHT);
              document.body.appendChild(renderer.domElement);
            }

            function initScene()
            {
              initCamera();
              initLight();
              initCube();
              initClouds();
              initRain();
            }

            function handleResize()
            {
              window.addEventListener(
                "resize",
                function()
                {
                  WIDTH = window.innerWidth;
                  HEIGHT = window.innerHeight;
                  renderer.setSize(WIDTH, HEIGHT);
                  camera.aspect = WIDTH / HEIGHT;
                  camera.updateProjectionMatrix();
                  render();
                }
              );
            }

            function initCamera()
            {
              camera = new THREE.PerspectiveCamera(60, WIDTH / HEIGHT, 1, 1000);
              // camera.position.set(0, 0, 5);
              // camera.lookAt(scene.position);
              camera.position.z = 1;
              camera.rotation.x = 1.16;
              camera.rotation.y = -0.12;
              camera.rotation.z = 0.27;
              cameraControls = new THREE.OrbitControls(
                camera, renderer.domElement
              );
              cameraControls.addEventListener("change",
                function()
                {
                  camera.updateProjectionMatrix();
                  render();
                }
              );
            }

            function initLight()
            {
              let ambientLight = new THREE.AmbientLight(0x555555);
              //ambientLight.position.set(1, 1, 1);
              scene.add(ambientLight);

              let directionalLight = new THREE.DirectionalLight(0xffeedd);
              directionalLight.position.set(0,0,1);
              scene.add(directionalLight);

              //let flash = new THREE.PointLight

            }

            function initCube()
            {
              geometry = new THREE.BoxGeometry(1, 1, 1);
              cube = new THREE.Mesh(geometry, material);
              //scene.add(cube);

              loader = new THREE.CubeTextureLoader();
              desert = loader.load([
                'desert_ft.jpg',
                'desert_bk.jpg',
                'desert_up.jpg',
                'desert_dn.jpg',
                'desert_rt.jpg',
                'desert_lf.jpg'
              ]);

              mountains = loader.load([
                'arid2_ft.jpg',
                'arid2_bk.jpg',
                'arid2_up.jpg',
                'arid2_dn.jpg',
                'arid2_rt.jpg',
                'arid2_lf.jpg'
              ]);

              snow = loader.load([
                'blizzard_ft.jpg',
                'blizzard_bk.jpg',
                'blizzard_up.jpg',
                'blizzard_dn.jpg',
                'blizzard_rt.jpg',
                'blizzard_lf.jpg'
              ]);

              test = loader.load([
                'posx.jpg',
                'negx.jpg',
                'posy.jpg',
                'negy.jpg',
                'posz.jpg',
                'negz.jpg'
              ]);

              
              //scene.background = texture;
            }

            function initClouds()
            {
              let cloudLoader = new THREE.TextureLoader();
              cloudLoader.load("smoke-1.png", function(texture){
                
                cloudGeo = new THREE.PlaneBufferGeometry(500, 500);
                cloudMaterial = new THREE.MeshLambertMaterial({
                  map: texture,
                  transparent: true
                });

                for(let p = 0; p < 25; p++)
                {
                  let cloud = new THREE.Mesh(cloudGeo, cloudMaterial);
                  cloud.position.set(
                    Math.random()*800 - 400,
                    500,
                    Math.random()*500 - 450
                  );
                  cloud.rotation.x = 1.16;
                  cloud.rotation.y = -0.12;
                  cloud.rotation.z = Math.random()*360;
                  cloud.material.opacity = 0.3;
                  cloudParticles.push(cloud);
                  scene.add(cloud);
                }


              });
            }

            function initRain()
            {
              rainGeo = new THREE.Geometry();
              for(let i = 0; i < rainCount; i++)
              {
                rainDrop = new THREE.Vector3(
                  Math.random() * 400 - 200,
                  Math.random() * 500 - 250,
                  Math.random() * 400 - 200
                );
                rainDrop.velocity = {};
                rainDrop.velocity = 0;
                rainGeo.vertices.push(rainDrop);
              }

              rainMaterial = new THREE.PointsMaterial({
                color: 0xaaaaaa,
                size: 0.1,
                transparent: true
              });

              rain = new THREE.Points(rainGeo, rainMaterial);
              scene.add(rain);
            }

            // dat.gui
            let guiControls = new function()
            {
              this.mountains = false;
              this.desert = false;
              this.snow = false;
              this.test = false;
            }

            function makeFalse()
            {
              guiControls.mountains = false;
              guiControls.desert = false;
              guiControls.snow = false;
              guiControls.test = false;
            }


            let datGUI = new dat.GUI();

            let environmentFolder = datGUI.addFolder("Environments");
            environmentFolder.add(guiControls, "mountains");
            environmentFolder.add(guiControls, "desert");
            environmentFolder.add(guiControls, "snow");
            environmentFolder.add(guiControls, "test");


            function render()
            {
              // if(~guiControls.mountains || ~guiControls.desert || ~guiControls.snow || ~guiControls.test)
              // {
              //   scene.background = null;
              // }
              if(guiControls.mountains)
              {
                //makeFalse();
                //guiControls.mountains = true;
                scene.background = mountains;

              }
              if(guiControls.desert)
              {
                //makeFalse();
                scene.background = desert;
              }
              if(guiControls.snow)
              {
                //makeFalse();
                scene.background = snow;
              }
              if(guiControls.test)
              {
                //makeFalse();
                scene.background = test;
              }

              cloudParticles.forEach(p => {
                p.rotation.z -= 0.0002;
              });

              rainGeo.vertices.forEach(p => {
                p.velocity -= 0.1 + Math.random() * 0.1;
                p.y += p.velocity;
                if (p.y < -200)
                {
                  p.y = 200;
                  p.velocity = 0;
                }
              });
              rainGeo.verticesNeedUpdate = true;

              requestAnimationFrame(render);
              renderer.render(scene, camera);
            }

            init();
            render();

    </script>
  </body>
</html>
